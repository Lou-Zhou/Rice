"""
Sports Analytics
"""

import numeric
import codeskulptor
from urllib import request
import comp140_module6 as sports

def read_matrix(filename):
    """
    Parse data from the file with the given filename into a matrix.

    input:
        - filename: a string representing the name of the file

    returns: a matrix containing the elements in the given file
    """
    a_file = request.urlopen(codeskulptor.file2url(filename))
    values = []
    for line in a_file.readlines():
        strline = line.decode('utf-8')
        new_line = strline.split(', ')
        row = [float(value) for value in new_line]
        values.append(row)
    return numeric.Matrix(values)
class LinearModel:
    """
    A class used to represent a Linear statistical
    model of multiple variables. This model takes
    a vector of input variables and predicts that
    the measured variable will be their weighted sum.
    """

    def __init__(self, weights):
        """
        Create a new LinearModel.

        inputs:
            - weights: an m x 1 matrix of weights
        """
        self._weights = weights

    def __str__(self):
        """
        Return: weights as a human readable string.
        """
        return str(self._weights)

    def get_weights(self):
        """
        Return: the weights associated with the model.
        """
        return self._weights

    def generate_predictions(self, inputs):
        """
        Use this model to predict a matrix of
        measured variables given a matrix of input data.

        inputs:
            - inputs: an n x m matrix of explanatory variables

        Returns: an n x 1 matrix of predictions
        """
        return inputs @ self.get_weights()

    def prediction_error(self, inputs, actual_result):
        """
        Calculate the MSE between the actual measured
        data and the predictions generated by this model
        based on the input data.

        inputs:
            - inputs: inputs: an n x m matrix of explanatory variables
            - actual_result: an n x 1 matrix of the corresponding
                             actual values for the measured variables

        Returns: a float that is the MSE between the generated
        data and the actual data
        """
        predictions = self.generate_predictions(inputs)
        mse = 0
        for value in range(inputs.shape()[0]):
            diff = actual_result[(value, 0)] - predictions[(value, 0)]
            diff = diff**2
            mse = mse + diff
        return mse / inputs.shape()[0]

def fit_least_squares(input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix with minimal Mean-Squared Error.

    inputs:
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    inversed = (input_data.transpose() @ input_data).inverse()
    #finds the inverse of the product of the transpose and the original
    weights = inversed @ input_data.transpose() @ output_data
    #creates weights based on data
    return LinearModel(weights)
def soft_threshold(value, increment):
    """ 
    Mathematical function which finds the value closest to 0
    Input: value, the value to move toward 0
           increment, the amount to move value
    Output: a new updated value which is closer to 0
    """
    output = 0
    #if value greater than increment, subtract by increment
    #and vice-versa
    if value > increment:
        output = value - increment
    if abs(value) <= increment:
        output = 0
    if value < -1 * increment:
        output = value + increment
    return output
def fit_lasso(param, iterations, input_data, output_data):
    """
    Create a Linear Model which predicts the output vector
    given the input matrix using the LASSO method.

    inputs:
        - param: a float representing the lambda parameter
        - iterations: an integer representing the number of iterations
        - input_data: an n x m matrix
        - output_data: an n x 1 matrix

    returns: a LinearModel object which has been fit to approximately
    match the data
    """
    least_squares_model = fit_least_squares(input_data, output_data)
    least_squares = least_squares_model.get_weights()
    #finds weights of least_squares
    idx = 0
    while idx < iterations:
        least_squares_old = least_squares.copy()
        transtimesorig = input_data.transpose() @ input_data
        for row in range(input_data.shape()[1]):
            least_squares_num_1 = (input_data.transpose() @ output_data)[(row,0)]
            least_squares_num_2 = (transtimesorig.getrow(row) @ least_squares)[(0,0)]
            #finds numerator and denominator based in inputs of a[i] and b[i]
            least_squares_den = transtimesorig[(row, row)]                                          
            least_added = (least_squares_num_1 - least_squares_num_2) / least_squares_den
            thres = param / (2 * transtimesorig[(row, row)])
            #changes value of least_squares based on soft_threshold
            least_squares[(row, 0)] = soft_threshold(least_squares[(row, 0)] + least_added, thres)
        least_squares_diff = (least_squares - least_squares_old).abs()
        if least_squares_diff.summation() < 10**-5:
            #check if movement is small enough
            return LinearModel(least_squares)
        idx = idx + 1
    return LinearModel(least_squares)
def run_experiment(iterations):
    """
    Using some historical data from 1954-2000, as
    training data, generate weights for a Linear Model
    using both the Least-Squares method and the
    LASSO method (with several different lambda values).

    Test each of these models using the historical
    data from 2001-2012 as test data.

    inputs:
        - iterations: an integer representing the number of iterations to use

    Print out the model's prediction error on the two data sets
    """
    #read all data
    stat54 = read_matrix("comp140_analytics_baseball.txt")
    wins54 = read_matrix("comp140_analytics_wins.txt")
    stat01 = read_matrix("comp140_analytics_baseball_test.txt")
    wins01 = read_matrix("comp140_analytics_wins_test.txt")
    least_squares = fit_least_squares(stat54, wins54)
    #Fits Least Squares Model
    print("Least Squares Model")
    print("Least Squares Model Prediction for 2010 Houston Astros: ")
    predictions = least_squares.generate_predictions(stat01)
    print(sports.extract_team_wins(predictions, "HOU", 2010))
    print("Actual Wins for 2010 Houston Astros: ")
    print(sports.extract_team_wins(wins01, "HOU", 2010))
    #Predicts and compares the wins for the 2010 Houston Astros
    print("Least Squares MSE:")
    print(least_squares.prediction_error(stat01, wins01))
    #Computes MSE
    params = [1500,10000,75000]
    for param in params:
        #Fits LASSO Squares Model for each parameter
        lasso = fit_lasso(param, iterations, stat54, wins54)
        print(f"\nLASSO Model with parameter {param}")
        print("LASSO Model Prediction for 2010 Houston Astros: ")
        predictions = lasso.generate_predictions(stat01)
        print(sports.extract_team_wins(predictions, "HOU", 2010))
        print("Actual Wins for 2010 Houston Astros: ")
        print(sports.extract_team_wins(wins01, "HOU", 2010))
        #Predicts and compares the wins for the 2010 Houston Astros
        print("LASSO MSE: ")
        print(lasso.prediction_error(stat01, wins01))
        #Computes MSE
#run_experiment(10)
